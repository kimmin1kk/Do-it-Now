# [1193] 분수찾기

---

## 📌 **Algorithm**

---

수학

구현

## 📍 **Logic**

---

```
long x = sc.nextLong();
long a = x;
long b = 0;

// 입력값이 i(i+1)/2 보다 작은 가장 큰 i값을 구함. (b)
// 또한, x를 가장 큰 i(i+1)/2로 나누었을 때의 나머지를 구하기 위해, 반복하면서 i를 빼기를 반복함. (a)
for (long i = 1; x >= (i * (i + 1) / 2); i++) {
    a -= i;
    b = i;
}

// 나머지가 0인 경우에는 이전 분수의 마지막 값. 외에는 그만큼 앞으로 가면 됨.
if (a == 0) {
// 지그제그로 돌기 때문에, 합이 짝수일 때와 홀수일 때를 나누어 생각해야 함.
    if (b % 2 == 0) {
        System.out.println(b + "/1");
    } else {
        System.out.println("1/" + b);
    }
} else {
    if (b % 2 == 0) {
        b++;
        System.out.println((b - a + 1) + "/" + a);
    } else {
        b++;
        System.out.println(a + "/" + (b - a + 1));
    }
}
```

- 분자와 분모의 합이 k인 분수는 k+1개이다. 편의상 k+1을 n이라 하자.
- 입력받은 x번째에 있는 분수의 분자, 분모의 합이 y라고 하자.
- 합이 y인 분수는 1부터 y-1까지의 합보다 큰 번호에 있을 것이다.
- 그래서 우선 x가 n이 몇일 때의 n(n+1)/2보다 큰지 그 최댓값을 구해야 했다. (b)
- 참고 : 1부터 n까지의 합은 n(n+1)
- 그래서 이를 구하면서, 합이 y인 분수에서도 몇 번째인지 알아야 했으므로, 나머지인 a도 함께 구했다.
- 이를 통해 a와 b를 구하고, x가 정확히 n(n+1)/2일 때와 아닐 때, 그리고 y가 홀수일 때와 짝수일 때로 총 4가지 상황에 따라 출력을 나누기만 하면 된다.

## ✒️ **Review**

---

- 어렵진 않은 문제였다. 다만, 1000만번 단일 루프를 돌았을 때, 0.5초가 시간초과가 뜨는지가 약간 고민이었지만 다행히 1000만번 정도는 괜찮았나보다.
- 그리고 출력에서 4가지 상황으로 나누는 게 막상 약간 헷갈렸다. 합과 개수가 1 차이가 나다보니 더 헷갈렸다.